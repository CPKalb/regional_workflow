#
#-----------------------------------------------------------------------
#
# Source the variable definitions file and the bash utility functions.
#
#-----------------------------------------------------------------------
#
. ${GLOBAL_VAR_DEFNS_FP}
. $USHDIR/source_util_funcs.sh
#
#-----------------------------------------------------------------------
#
# Save current shell options (in a global array).  Then set new options
# for this script/function.
#
#-----------------------------------------------------------------------
#
{ save_shell_opts; set -u +x; } > /dev/null 2>&1
#
#-----------------------------------------------------------------------
#
# Get the full path to the file in which this script/function is located 
# (scrfunc_fp), the name of that file (scrfunc_fn), and the directory in
# which the file is located (scrfunc_dir).
#
#-----------------------------------------------------------------------
#
scrfunc_fp=$( $READLINK -f "${BASH_SOURCE[0]}" )
scrfunc_fn=$( basename "${scrfunc_fp}" )
scrfunc_dir=$( dirname "${scrfunc_fp}" )
#
#-----------------------------------------------------------------------
#
# Print message indicating entry into script.
#
#-----------------------------------------------------------------------
#
print_info_msg "
========================================================================
Entering script:  \"${scrfunc_fn}\"
In directory:     \"${scrfunc_dir}\"

This is the ex-script for the task that pulls MRMS obs data from NOAA's
HPSS.
========================================================================"
#
#-----------------------------------------------------------------------
#
# Specify the set of valid argument names for this script/function.  
# Then process the arguments provided to this script/function (which 
# should consist of a set of name-value pairs of the form arg1="value1",
# etc).
#
#-----------------------------------------------------------------------
#
valid_args=()
process_args valid_args "$@"
#
#-----------------------------------------------------------------------
#
# For debugging purposes, print out values of arguments passed to this
# script.  Note that these will be printed out only if VERBOSE is set to
# TRUE.
#
#-----------------------------------------------------------------------
#
print_input_args "valid_args"
#
#-----------------------------------------------------------------------
#
# Set the field base name used in the MRMS obs file names.
#
#-----------------------------------------------------------------------
#
if [ "${VAR}" = "REFC" ]; then
  field_base_name="MergedReflectivityQCComposite"
  level="_00.50_"
elif [ "${VAR}" = "RETOP" ]; then
  field_base_name="EchoTop"
  level="_18_00.50_"
else
  print_err_msg_exit "
A method for setting \"field_base_name\" and \"level\" has not been specified
for this field (VAR):
  VAR = \"$VAR\""
fi
#
#-----------------------------------------------------------------------
#
# Get all cycle days and hours for which there is forecast output (the
# output day and hour may be generated by more than one forecasts).  Each
# member of the resulting list (cdates_fcst_output) is unique and has
# the form YYYYMMDDHH.
#
#-----------------------------------------------------------------------
#
# The array ALL_CDATES contains a list of the forecasts' starting times
# (in the form YYYYMMDDHH).  For clarity, save in a new renamed array.
cdates_init=( $( printf "%s " "${ALL_CDATES[@]}" ))
# The scalar variable FHR_LIST contains all the output forecast hours
# for any given forecast.  For convenience, convert it to an array.
fhr_list=( $( printf "%s " "${FHR_LIST[@]}" ))

cdates_fcst_output=()
num_cdates_init=${#cdates_init[@]}
num_fhrs=${#fhr_list[@]}
for (( i=0; i<${num_cdates_init}; i++ )); do
  yyyymmdd=${cdates_init[$i]:0:8}
  hh=${cdates_init[$i]:8:2}
  for (( j=0; j<${num_fhrs}; j++ )); do
    fhr=${fhr_list[$j]}
    cdate=$( date --date="$yyyymmdd + $hh hours + $fhr hours" +"%Y%m%d%H" )
    cdates_fcst_output+=("$cdate")
  done
done

# Convert the cdates_fcst_output array to a string for easier sorting/
# unique-ing.
cdates_fcst_output=$( printf "%s\n" "${cdates_fcst_output[@]}" )
# Remove duplicate entries in cdates_fcst_output.
cdates_fcst_output=$( echo "${cdates_fcst_output}" | sort -n | uniq )
#
#-----------------------------------------------------------------------
#
# Get all days (without hours) for which there is forecast output.  Each
# member of the resulting list (days_fcst_output) is unique and has the
# form YYYYMMDD.
#
#-----------------------------------------------------------------------
#
regex_search="^([0-9]{8})(.*)$"
days_fcst_output=$( echo "${cdates_fcst_output}" | $SED -n -r "s|${regex_search}|\1|p" )
days_fcst_output=$( echo "${days_fcst_output}" | sort -n | uniq )
#
# Pad the list of forecast output days with a day before the first and
# a day after the last.  This ensures continuity at day start/end times
# when matching the forecast times with the times at which obs are
# available.
#
readarray -t "days_fcst_output" <<< "${days_fcst_output}"
first_day=${days_fcst_output[0]}
prev_day=$( date --date="${first_day} - 1 day" +"%Y%m%d" )
days_fcst_output=("${prev_day}" $(printf "%s " "${days_fcst_output[@]}"))
last_day=${days_fcst_output[-1]}
next_day=$( date --date="${last_day} + 1 day" +"%Y%m%d" )
days_fcst_output+=("${next_day}")

days_fcst_output=$( printf "%s\n" "${days_fcst_output[@]}" )
#
#-----------------------------------------------------------------------
#
# Set the names of the MRMS files corresponding to the forecast output
# times.  Below, we will rename the MRMS obs files with time stamps
# closest to these times to these file names (because the obs are usually
# not available at exactly the forecast output times).
#
#-----------------------------------------------------------------------
#
mrms_grib2_fns_fcst_output+=()
readarray -t "cdates_fcst_output" <<< "${cdates_fcst_output}"
num_fcst_output_times=${#cdates_fcst_output[@]}
for (( i=0; i<${num_fcst_output_times}; i++ )); do
  yyyymmdd=${cdates_fcst_output[$i]:0:8}
  hh=${cdates_fcst_output[$i]:8:2}
  fn="${field_base_name}${level}${yyyymmdd}-${hh}0000.grib2"
  mrms_grib2_fns_fcst_output+=("$fn")
done
mrms_grib2_fns_fcst_output=$( printf "%s\n" "${mrms_grib2_fns_fcst_output[@]}" )
#
#-----------------------------------------------------------------------
#
# Using the days for which there will be forecast output plus the two
# padding days, construct the paths (on HPSS) to all tar files on NOAA
# HPSS that contain MRMS data.  Then, for each such file (i.e. for each
# day), construct the relative paths within each tar file of all the
# gzipped grib2 files that contain data for the current field and level.
#
#-----------------------------------------------------------------------
#
tar_files=()
mrms_grib2gz_fps_in_tar=""
readarray -t "days_fcst_output" <<< "${days_fcst_output}"
num_days_fcst_output=${#days_fcst_output[@]}
for (( i=0; i<${num_days_fcst_output}; i++ )); do

  yyyymmdd=${days_fcst_output[$i]}
  yyyy=${yyyymmdd:0:4}
  mm=${yyyymmdd:4:2}
  dd=${yyyymmdd:6:2}

  base_dir="/NCEPPROD/hpssprod/runhistory/rh${yyyy}/${yyyy}${mm}/${yyyymmdd}"
# Flag that indicates whether tar file was found in NOAA HPSS.
  found_tar_file="FALSE"
# The first case here doesn't seem to work for 20200227 through 202020302
# because the expected files do not exist (or possibly have different
# names).
  if [ ${yyyymmdd} -ge 20190101 ] && [ ${yyyymmdd} -lt 20200303 ]; then
    subdir_options=( "gyre" "tide" )
    for subdir in "${subdir_options[@]}"; do
      tar_file="${base_dir}/ldmdata."${subdir}".${yyyymmdd}.tar"
      hsi "ls -1 ${tar_file}" >& /dev/null && {
        found_tar_file="TRUE";
        break;
      }
    done
  elif [ ${yyyymmdd} -ge 20200303 ]; then
    tar_file="${base_dir}/dcom_prod_ldmdata_obs.tar"
    hsi "ls -1 ${tar_file}" >& /dev/null && {
      found_tar_file="TRUE";
    }
  else
    print_err_msg_exit "
A method for pulling MRMS obs files has not been specified for the following
date:
  ${yyyymmdd}"
  fi

  if [ "${found_tar_file}" = "FALSE" ]; then
    print_err_msg_exit "
Tarred MRMS obs file (tar_file) does not exist on NOAA HPSS for ${yyyymmdd}:
  tar_file = \"${tar_file}\""
  fi

  tar_files+=("$tar_file")

  print_info_msg "\
Getting list of all gzipped grib2 MRMS files for the current day (yyyymmdd)
that contain information for the current field (field_base_name) and
level (level):
  yyyymmdd = $yyyymmdd
  field_base_name = \"${field_base_name}\"
  level = \"$level\"
"

  gzip_file_list=$( htar -tf ${tar_file} | \
                    grep -E "${field_base_name}${level}${yyyy}${mm}${dd}-[0-9]{6}.grib2.gz" | \
                    awk '{print $7}' ) || \
  print_err_msg_exit "\
Call to htar to get list of all gzipped grib2 MRMS files for the current
day (yyyymmdd) that contain information for the current field (field_base_name)
and level (level) failed:
  yyyymmdd = $yyyymmdd
  field_base_name = \"${field_base_name}\"
  level = \"$level\""

  mrms_grib2gz_fps_in_tar="${mrms_grib2gz_fps_in_tar}
${gzip_file_list}"

done

# Remove leading newline, then sort/unique-ify.
mrms_grib2gz_fps_in_tar="${mrms_grib2gz_fps_in_tar:1}"
mrms_grib2gz_fps_in_tar=$( echo "${mrms_grib2gz_fps_in_tar}" | sort -n | uniq )
#
#-----------------------------------------------------------------------
#
# Get the paths (within each daily tar file) and file names of the
# gzipped grib2 files.
#
#-----------------------------------------------------------------------
#
regex_search="^(.*)\/(.*)$"
mrms_grib2gz_subdirs_in_tar=$( echo "${mrms_grib2gz_fps_in_tar}" | $SED -n -r "s|${regex_search}|\1|p" )
mrms_grib2gz_fns_in_tar=$( echo "${mrms_grib2gz_fps_in_tar}" | $SED -n -r "s|${regex_search}|\2|p" )
#
# For convenience, extract the list of days/times, in the form
#
#   yyyymmdd-HHMMSS
#
# from both the list of grib2gz files available on NOAA HPSS (in various
# daily tar files) and the list of yet-to-be-created obs files with names
# that contain the exact forecast output times.
#
regex_search="^(.*)([0-9]{8})-([0-9]{6})(.*)$"
times_in_tar=$( echo "${mrms_grib2gz_fns_in_tar}" | $SED -n -r "s|${regex_search}|\2\3|p" )
times_fcst_output=$( echo "${mrms_grib2_fns_fcst_output}" | $SED -n -r "s|${regex_search}|\2\3|p" )
#
# For each forecast output time, find the index of the obs time that is
# closest to the former.  We do not allow any obs time to be offset by
# more than diff_secs_max seconds from the forecast time it is being
# matched to.
#
readarray -t "times_in_tar" <<< "${times_in_tar}"
readarray -t "times_fcst_output" <<< "${times_fcst_output}"

diff_secs_max="900"  # Max of 15 minutes difference.
inds_in_tar=()

j=0
crnt="${times_fcst_output[$j]}"
next="000000000000"

num_tar_files=${#times_in_tar[@]}
for (( i=0; i<${num_tar_files}; i++ )); do

  prev="${next}"
  next="${times_in_tar[$i]}"

  while [ "${crnt}" -ge "${prev}" ] && [ "${crnt}" -lt "${next}" ]; do

    yyyymmdd_prev=${prev:0:8}
    hh_prev=${prev:8:2}
    mm_prev=${prev:10:2}
    ss_prev=${prev:12:2}
    prev_secs=$( date --date="${yyyymmdd_prev} + ${hh_prev} hours + ${mm_prev} minutes + ${ss_prev} seconds" +"%s" )

    yyyymmdd_crnt=${crnt:0:8}
    hh_crnt=${crnt:8:2}
    mm_crnt=${crnt:10:2}
    ss_crnt=${crnt:12:2}
    crnt_secs=$( date --date="${yyyymmdd_crnt} + ${hh_crnt} hours + ${mm_crnt} minutes + ${ss_crnt} seconds" +"%s" )

    yyyymmdd_next=${next:0:8}
    hh_next=${next:8:2}
    mm_next=${next:10:2}
    ss_next=${next:12:2}
    next_secs=$( date --date="${yyyymmdd_next} + ${hh_next} hours + ${mm_next} minutes + ${ss_next} seconds" +"%s" )

    crnt_mns_prev=$(( ${crnt_secs} - ${prev_secs} ))
    next_mns_crnt=$(( ${next_secs} - ${crnt_secs} ))
    if [ "${crnt_mns_prev}" -le "${next_mns_crnt}" ]; then
      diff_secs="${crnt_mns_prev}"
      tmp="$prev"
      if [ $i -ne 0 ]; then
        inds_in_tar+=( $((i-1)) )
      else
        print_err_msg_exit "\
The oldest forecast output time (crnt) is older than the oldest obs
time (next):
  crnt = $crnt
  next = $next
This should not be happening given that the days for which obs are
considered are padded with one before the earliest forecast output time.
"
      fi
    else
      diff_secs="${next_mns_crnt}"
      tmp="$next"
      inds_in_tar+=( $i )
    fi
    if [ ${diff_secs} -gt ${diff_secs_max} ]; then
      print_err_msg_exit "\
Time time difference (diff_secs) between the forecast output time and
the closest obs time is larger than the maximum allowed (diff_secs_max):
  diff_secs_max = ${diff_secs_max} seconds
  diff_secs = ${diff_secs} seconds"
    fi

    j=$((j+1))
    if [ "$j" -lt "${num_fcst_output_times}" ]; then
      crnt="${times_fcst_output[$j]}"
    else
      break 2
    fi

  done

done
#
# Make sure that for each forecast output time, there is an index that
# maps the former into the list of gzipped grib2 files.  This means the
# number of elements in inds_in_tar must equal the number of forecast
# output times.
#
num_inds_in_tar=${#inds_in_tar[@]}
if [ "${num_inds_in_tar}" -ne "${num_fcst_output_times}" ]; then
  print_err_msg_exit "\
The length of the array containing indices into the list of gzipped grib2
files (num_inds_in_tar) is not equal to the number of forecast output
times (num_fcst_output_times):
  num_fcst_output_times = ${num_fcst_output_times}
  num_inds_in_tar = ${num_inds_in_tar}"
fi
#
#-----------------------------------------------------------------------
#
# Get the list of gzipped grib2 files to extract from the tar files on
# NOAA HPSS.  These consist of only those files which have been matched
# with the forecast output times (i.e. the files that contain obs at
# times that are closest to the forecast output times).
#
#-----------------------------------------------------------------------
#
readarray -t "mrms_grib2gz_subdirs_in_tar" <<< "${mrms_grib2gz_subdirs_in_tar}"
readarray -t "mrms_grib2gz_fns_in_tar" <<< "${mrms_grib2gz_fns_in_tar}"
for (( j=0; j<${num_fcst_output_times}; j++ )); do
  i=${inds_in_tar[$j]}
  time_hpss=${times_in_tar[$i]}
  yyyymmdd=${time_hpss:0:8}
  hhmmss=${time_hpss:8:6}
  mrms_fps_extract_from_hpss+=("${mrms_grib2gz_subdirs_in_tar[$i]}/${mrms_grib2gz_fns_in_tar[$i]}")
done
mrms_fps_extract_from_hpss=$( printf "%s\n" "${mrms_fps_extract_from_hpss[@]}" )
#
#-----------------------------------------------------------------------
#
# Create base directories in which to extract/unzip obs data.
#
#-----------------------------------------------------------------------
#
mrms_dir=$( $READLINK -m "${OBS_DIR}/.." )
if [[ ! -d "${mrms_dir}" ]]; then
  mkdir_vrfy -p ${mrms_dir}
fi

# Base directory for raw (gzipped) MRMS data from NOAA HPSS.
mrms_raw="${mrms_dir}/raw"
if [[ ! -d "${mrms_raw}" ]]; then
  mkdir_vrfy -p ${mrms_raw}
fi

# Base directory for processed (unzipped grib2) MRMS data.
mrms_proc="${mrms_dir}/proc"
if [[ ! -d "${mrms_proc}" ]]; then
  mkdir_vrfy -p ${mrms_proc}
fi
#
#-----------------------------------------------------------------------
#
# For each day for which there is forecast output (including the two
# padding days):
#
# 1) Extract the gzipped grib2 files from the tar file on NOAA HPSS for
#    that day into the raw MRMS obs directory.
# 2) Move the files to the processed MRMS directory and rename them to
#    the reflect the closest forecast output times.
# 3) Unzip the files in the processed MRMS directory.
#
#-----------------------------------------------------------------------
#
for (( i=0; i<${num_days_fcst_output}; i++ )); do

  yyyymmdd="${days_fcst_output[$i]}"

  regex_search="(.*${yyyymmdd}-[0-9]{6}\.grib2\.gz)"
  fps_to_extract=$( echo "${mrms_fps_extract_from_hpss}" | \
                    ${SED} -n -r "s|${regex_search}|\1|p" )

  regex_search="(.*${yyyymmdd}-[0-9]{2}0000\.grib2)"
  new_fns=$( echo "${mrms_grib2_fns_fcst_output}" | \
             ${SED} -n -r "s|${regex_search}|\1.gz|p" )

  readarray -t "fps_to_extract" <<< "${fps_to_extract}"
  num_files_to_extract=${#fps_to_extract[@]}
  readarray -t "new_fns" <<< "${new_fns}"
  num_new_fns=${#new_fns[@]}
  if [ "${num_files_to_extract}" != "${num_new_fns}" ]; then
    print_err_msg_exit "\
The number of files to extract (num_files_to_extract) does not equal the
number of new file names (num_new_fns):
  num_files_to_extract = \"${num_files_to_extract}\"
  num_new_fns = \"${num_new_fns}\"
Each extracted gzipped grib2 file will be renamed and so must have a
corresponding new name."
  fi

  if [ -z "${fps_to_extract}" ]; then
  
    print_info_msg "\
No MRMS obs files to extract for day:
  yyyymmdd = $yyyymmdd
"

  else

    print_info_msg "\
Extracting and unzipping MRMS obs files for day:
  yyyymmdd = $yyyymmdd
"

    day_raw_fp="${mrms_raw}/${yyyymmdd}"
    mkdir_vrfy -p ${day_raw_fp}
    cd_vrfy ${day_raw_fp}

    tar_file=${tar_files[$i]}
    htar -xvf "${tar_file}" ${mrms_fps_extract_from_hpss} || { \
      exit_code=$? ;
      print_err_msg_exit "\
htar command for extracting gzip files from the tar file (tar_file) on
NOAA HPSS into the daily directory for raw observations (day_raw_fp)
returned with a non-zero exit code (exit_code):
  tar_file = \"${tar_file}\"
  day_raw_fp = \"${day_raw_fp}\"
  exit_code = ${exit_code}" ;
    }

    day_proc_fp="${mrms_proc}/${yyyymmdd}"
    mkdir_vrfy -p ${day_proc_fp}

    for (( j=0; j<${num_files_to_extract}; j++ )); do
      new_fn=${new_fns[$j]}
      cp_vrfy ${day_raw_fp}/${fps_to_extract[$j]} ${day_proc_fp}/${new_fn}
      cd_vrfy ${day_proc_fp}
      gunzip --force ${new_fn}
    done

  fi

done
